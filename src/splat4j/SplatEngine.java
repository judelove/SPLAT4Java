/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package splat4j;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import splat4j.ITWOM.ITWOM3;
import splat4j.ITWOM.ITWOM3.ITWOMResult;
import static splat4j.SPLAT4J.ani_filename;
import splat4j.input.LRParameters;
import splat4j.output.ANOFile;

/**
 *
 * @author Jude Mukundane
 */
public class SplatEngine {

    private Path path;
    private LR lr;
    private Dem[] dem;
    private Configuration config;
    private String string;
    private String sdfPath;
    private String opened = "0";
    private String name = "splat4J";
    private String version = "1.4.2(j)";
    private String dashes = "-------------------------------------------------------------------------";
    private double earthradius, maxRange = 0.0;
    private double forcedErp = -1.0;
    private double dpp, altitude, LRaltitude;
    private double ppd;
    private double fzoneClearance = 0.6;
    private double forcedFreq = -1;
    private double clutter;
    private int minNorth = 90;
    private int maxNorth = -90;
    private int minWest = 360;
    private int maxWest = -1;
    private int ippd;
    private int mpi;
    private int maxElevation = -32768;
    private int minElevation = 32768;
    private int bzerror;
    private int contourThreshold;
    private double[] elev;  
    int mask_value =1;
    private boolean noSitesReport, generatePpm,isTransparentPng, coverage, LRmap, terrain_plot, elevation_plot, height_plot, map, longley_plot, norm, topomap, pt2pt_mode, area_model, ngs, nolospath, fresnel_plot, command_line_log, metric, kml, dbm, geo, smoothContours, olditm, smooth_contours, area_mode, gpsav;


    SplatEngine(Configuration config) {
        this.config = config;
        this.elev = new double[config.ARRAYSIZE + 10];
        this.dem = new Dem[this.config.MAXPAGES];
        for (int x = 0; x < config.MAXPAGES; x++) {
            dem[x] = new Dem(-1, 90, 360, -90, 32768, -32768, config.IPPD);
        }
    }

    
    int PutMask(double lat, double lon, int value) {
        /* Lines, text, markings, and coverage areas are stored in a
	   mask that is combined with topology data when topographic
	   maps are generated by SPLAT!.  This function sets and resets
	   bits in the mask based on the latitude and longitude of the
	   area pointed to. */

        int x = 0, y = 0, indx;
        boolean found;

        for (indx = 0, found = false; indx < getConfig().MAXPAGES && !found;) {
            x = (int) Math.rint(getPpd() * (lat - dem[indx].getMinNorth()));
            y = getMpi() - (int) Math.rint(getPpd() * (Utils.lonDiff(dem[indx].getMaxWest(), lon)));

            if (x >= 0 && x <= getMpi() && y >= 0 && y <= getMpi()) {
                found = true;
            } else {
                indx++;
            }
        }

        if (found) {
            dem[indx].setMask(x, y, value);
            return ((int) dem[indx].getMask()[x][y]);
        } else {
            return -1;
        }
    }

    int OrMask(double lat, double lon, int value) {
        /* Lines, text, markings, and coverage areas are stored in a
	   mask that is combined with topology data when topographic
	   maps are generated by SPLAT!.  This function sets bits in
	   the mask based on the latitude and longitude of the area
	   pointed to. */

        int x = 0, y = 0, indx;
        boolean found;

        for (indx = 0, found = false; indx < dem.length && !found;) {
            x = (int) Math.rint(ppd * (lat - dem[indx].getMinNorth()));
            y = mpi - (int) Math.rint(ppd * (Utils.lonDiff(dem[indx].getMaxWest(), lon)));

            if (x >= 0 && x <= mpi && y >= 0 && y <= mpi) {
                found = true;
            } else {
                indx++;
            }
        }

        if (found) {
            dem[indx].setMask(x, y, dem[indx].getMask()[x][y] | value);
            return ((int) dem[indx].getMask()[x][y]);
        } else {
            return -1;
        }
    }

    int GetMask(double lat, double lon) {
        /* This function returns the mask bits based on the latitude
	   and longitude given. */

        return (OrMask(lat, lon, 0));
    }

    int PutSignal(double lat, double lon, int signal) {
        /* This function writes a signal level (0-255)
	   at the specified location for later recall. */

        int x = 0, y = 0, indx;
        boolean found;

        for (indx = 0, found = false; indx < getConfig().MAXPAGES && !found;) {
            x = (int) Math.rint(getPpd() * (lat - dem[indx].getMinNorth()));
            y = getMpi() - (int) Math.rint(getPpd() * (Utils.lonDiff(dem[indx].getMaxWest(), lon)));

            if (x >= 0 && x <= getMpi() && y >= 0 && y <= getMpi()) {
                found = true;
            } else {
                indx++;
            }
        }

        if (found) {
            dem[indx].setSignal(x, y, signal);
            return (dem[indx].getSignal()[x][y]);
        } else {
            return 0;
        }
    }

    int GetSignal(double lat, double lon) {
        /* This function reads the signal level (0-255) at the
	   specified location that was previously written by the
	   complimentary PutSignal() function. */

        int x = 0, y = 0, indx;
        boolean found;

        for (indx = 0, found = false; indx < getConfig().MAXPAGES && !found;) {
            x = (int) Math.rint(getPpd() * (lat - dem[indx].getMinNorth()));
            y = getMpi() - (int) Math.rint(getPpd() * (Utils.lonDiff(dem[indx].getMaxWest(), lon)));

            if (x >= 0 && x <= getMpi() && y >= 0 && y <= getMpi()) {
                found = true;
            } else {
                indx++;
            }
        }

        if (!found) {
            return (dem[indx].getSignal()[x][y]);
        } else {
            return 0;
        }
    }

    double elevationAngle2(Site source, Site destination, double er) {
        /* This function returns the angle of elevation (in degrees)
	   of the destination as seen from the source location, UNLESS
	   the path between the sites is obstructed, in which case, the
	   elevation angle to the first obstruction is returned instead.
	   "er" represents the earth radius. */

        int x;
        boolean block = false;
        double source_alt, destination_alt, cos_xmtr_angle,
                cos_test_angle, test_alt, elevation, distance,
                source_alt2, first_obstruction_angle = 0.0;
        Path temp;

        temp = Utils.readPath(source, destination, this, config);

        distance = 5280.0 * Utils.distance(source, destination, config);
        source_alt = er + source.getAlt() + Utils.getElevation(source, this, config);
        destination_alt = er + destination.getAlt() + Utils.getElevation(destination, this, config);
        source_alt2 = source_alt * source_alt;

        /* Calculate the cosine of the elevation angle of the
	   destination (receiver) as seen by the source (transmitter). */
        cos_xmtr_angle = ((source_alt2) + (distance * distance) - (destination_alt * destination_alt)) / (2.0 * source_alt * distance);

        /* Test all points in between source and destination locations to
	   see if the angle to a topographic feature generates a higher
	   elevation angle than that produced by the destination.  Begin
	   at the source since we're interested in identifying the FIRST
	   obstruction along the path between source and destination. */
        for (x = 2, block = false; x < path.getLength() && !block; x++) {
            distance = 5280.0 * path.getDistance()[x];

            test_alt = getEarthradius() + (path.getElevation()[x] == 0.0 ? path.getElevation()[x] : path.getElevation()[x] + getClutter());

            cos_test_angle = ((source_alt2) + (distance * distance) - (test_alt * test_alt)) / (2.0 * source_alt * distance);

            /* Compare these two angles to determine if
		   an obstruction exists.  Since we're comparing
		   the cosines of these angles rather than
		   the angles themselves, the sense of the
		   following "if" statement is reversed from
		   what it would be if the angles themselves
		   were compared. */
            if (cos_xmtr_angle >= cos_test_angle) {
                block = true;
                first_obstruction_angle = ((Math.acos(cos_test_angle)) / getConfig().DEG2RAD) - 90.0;
            }
        }

        if (block) {
            elevation = first_obstruction_angle;
        } else {
            elevation = ((Math.acos(cos_xmtr_angle)) / getConfig().DEG2RAD) - 90.0;
        }

        path = temp;

        return elevation;
    }

    void PlaceMarker(Site location) {
        /* This function places text and marker data in the mask array
	   for illustration on topographic maps generated by SPLAT!.
	   By default, SPLAT! centers text information BELOW the marker,
	   but may move it above, to the left, or to the right of the
	   marker depending on how much room is available on the map,
	   or depending on whether the area is already occupied by
	   another marker or label.  If no room or clear space is
	   available on the map to place the marker and its associated
	   text, then the marker and text are not written to the map. */

        int a, b, c, byt;
        boolean ok2print, occupied;
        double x, y, lat, lon, textx = 0.0, texty = 0.0, xmin, xmax,
                ymin, ymax, p1, p3, p6, p8, p12, p16, p24, label_length;

        xmin = (double) minNorth; // min_north;
        xmax = (double) maxNorth; //max_north;
        ymin = (double) minWest; //min_west;
        ymax = (double) maxWest; //max_west;
        lat = location.getLat();
        lon = location.getLon();

        if (lat < xmax && lat >= xmin && (Utils.lonDiff(lon, ymax) <= 0.0) && (Utils.lonDiff(lon, ymin) >= getDpp())) {
            p1 = 1.0 / getPpd();
            p3 = 3.0 / getPpd();
            p6 = 6.0 / getPpd();
            p8 = 8.0 / getPpd();
            p12 = 12.0 / getPpd();
            p16 = 16.0 / getPpd();
            p24 = 24.0 / getPpd();

            ok2print = false;
            occupied = false;

            /* Is Marker Position Clear Of Text Or Other Markers? */
            for (a = 0, x = lat - p3; (x <= xmax && x >= xmin && a < 7); x += p1, a++) {
                for (b = 0, y = lon - p3; (Utils.lonDiff(y, ymax) <= 0.0) && (Utils.lonDiff(y, ymin) >= getDpp()) && b < 7; y += p1, b++) {
                    occupied |= ((GetMask(x, y) & 2) > 0);
                }
            }

            if (!occupied) {
                /* Determine Where Text Can Be Positioned */

 /* label_length=length in pixels.
			   Each character is 8 pixels wide. */
                label_length = p1 * (double) ((location.getName().length()) << 3);

                if ((Utils.lonDiff(lon + label_length, ymax) <= 0.0) && (Utils.lonDiff(lon - label_length, ymin) >= getDpp())) {
                    /* Default: Centered Text */

                    texty = lon + label_length / 2.0;

                    if ((lat - p8) >= p16) {
                        /* Position Text Below The Marker */

                        textx = lat - p8;

                        x = textx;
                        y = texty;

                        /* Is This Position Clear Of
					   Text Or Other Markers? */
                        for (a = 0, occupied = false; a < 16; a++) {
                            for (b = 0; b < (int) (location.getName().length()); b++) {
                                for (c = 0; c < 8; c++, y -= p1) {
                                    occupied |= ((GetMask(x, y) & 2) > 0);
                                }
                            }
                            x -= p1;
                            y = texty;
                        }

                        x = textx;
                        y = texty;

                        if (!occupied) {
                            ok2print = true;
                        }
                    } else {
                        /* Position Text Above The Marker */

                        textx = lat + p24;

                        x = textx;
                        y = texty;

                        /* Is This Position Clear Of
					   Text Or Other Markers? */
                        for (a = 0, occupied = false; a < 16; a++) {
                            for (b = 0; b < (int) (location.getName().length()); b++) {
                                for (c = 0; c < 8; c++, y -= p1) {
                                    occupied |= ((GetMask(x, y) & 2) > 0);
                                }
                            }
                            x -= p1;
                            y = texty;
                        }

                        x = textx;
                        y = texty;

                        if (!occupied) {
                            ok2print = true;
                        }
                    }
                }

                if (!ok2print) {
                    if (Utils.lonDiff(lon - label_length, ymin) >= getDpp()) {
                        /* Position Text To The
					   Right Of The Marker */

                        textx = lat + p6;
                        texty = lon - p12;

                        x = textx;
                        y = texty;

                        /* Is This Position Clear Of
					   Text Or Other Markers? */
                        for (a = 0, occupied = false; a < 16; a++) {
                            for (b = 0; b < (int) (location.getName().length()); b++) {
                                for (c = 0; c < 8; c++, y -= p1) {
                                    occupied |= ((GetMask(x, y) & 2) > 0);
                                }
                            }
                            x -= p1;
                            y = texty;
                        }

                        x = textx;
                        y = texty;

                        if (!occupied) {
                            ok2print = true;
                        }
                    } else {
                        /* Position Text To The
					   Left Of The Marker */

                        textx = lat + p6;
                        texty = lon + p8 + (label_length);

                        x = textx;
                        y = texty;

                        /* Is This Position Clear Of
					   Text Or Other Markers? */
                        for (a = 0, occupied = false; a < 16; a++) {
                            for (b = 0; b < (int) (location.getName().length()); b++) {
                                for (c = 0; c < 8; c++, y -= p1) {
                                    occupied |= ((GetMask(x, y) & 2) > 0);
                                }
                            }
                            x -= p1;
                            y = texty;
                        }

                        x = textx;
                        y = texty;

                        if (!occupied) {
                            ok2print = true;
                        }
                    }
                }

                /* textx and texty contain the latitude and longitude
			   coordinates that describe the placement of the text
			   on the map. */
                if (ok2print) {
                    /* Draw Text */

                    x = textx;
                    y = texty;

                    for (a = 0; a < 16; a++) {
                        for (b = 0; b < (int) (location.getName().length()); b++) {
                            //byt=fontdata[16*(location.getName()[b])+a];
                            byt = FontData.get(16 * (location.getName().charAt(b)) + a);
                            for (c = 128; c > 0; c = c >> 1, y -= p1) {
                                if ((byt & c) > 0) {
                                    OrMask(x, y, 2);
                                }
                            }
                        }

                        x -= p1;
                        y = texty;
                    }

                    /* Draw Square Marker Centered
				   On Location Specified */
                    for (a = 0, x = lat - p3; (x <= xmax && x >= xmin && a < 7); x += p1, a++) {
                        for (b = 0, y = lon - p3; (Utils.lonDiff(y, ymax) <= 0.0) && (Utils.lonDiff(y, ymin) >= getDpp()) && b < 7; y += p1, b++) {
                            OrMask(x, y, 2);
                        }
                    }
                }
            }
        }
    }
    
    void loadFiles(ArrayList<Site> txSites, ArrayList<Site> rxSites,  int max_txsites) {
        if (ani_filename != null) {
            LRParameters lrp = new LRParameters(this);
            lrp.loadLRFile(txSites.get(0).getFilename());
            /* Get ERP status */
            ANOFile anofile = new ANOFile(config, this);
            anofile.LoadANO(ani_filename);

            for (int x = 0; x < txSites.size() && x < max_txsites; x++) {
                PlaceMarker(txSites.get(x));
            }

            if (rxSites.size() > 0) {
                PlaceMarker(rxSites.get(0));
            }
        }
    }


    void PlotPath(Site source, Site destination, int mask_value) {
        /* This function analyzes the path between the source and
	   destination locations.  It determines which points along
	   the path have line-of-sight visibility to the source.
	   Points along with path having line-of-sight visibility
	   to the source at an AGL altitude equal to that of the
	   destination location are stored by setting bit 1 in the
	   mask[][] array, which are displayed in green when PPM
	   maps are later generated by SPLAT!. */

        char block;
        int x, y;
        double cos_xmtr_angle, cos_test_angle, test_alt;
        double distance, rx_alt, tx_alt;

        path = Utils.readPath(source, destination, this, config);

        for (y = 0; y < path.getLength(); y++) {
            /* Test this point only if it hasn't been already
		   tested and found to be free of obstructions. */

            if ((GetMask(path.getLat(y), path.getLon(y)) & mask_value) == 0) {
                distance = 5280.0 * path.getDistance()[y];
                tx_alt = getEarthradius() + source.getAlt() + path.getElevation()[0];
                rx_alt = getEarthradius() + destination.getAlt() + path.getElevation()[y]; //.elevation[y];

                /* Calculate the cosine of the elevation of the
			   transmitter as seen at the temp rx point. */
                cos_xmtr_angle = ((rx_alt * rx_alt) + (distance * distance) - (tx_alt * tx_alt)) / (2.0 * rx_alt * distance);

                for (x = y, block = 0; x >= 0 && block == 0; x--) {
                    distance = 5280.0 * (path.getDistance()[y] - path.getDistance()[x]);
                    test_alt = getEarthradius() + (path.getElevation()[x] == 0.0 ? path.getElevation()[x] : path.getElevation()[x] + getClutter());

                    cos_test_angle = ((rx_alt * rx_alt) + (distance * distance) - (test_alt * test_alt)) / (2.0 * rx_alt * distance);

                    /* Compare these two angles to determine if
				   an obstruction exists.  Since we're comparing
				   the cosines of these angles rather than
				   the angles themselves, the following "if"
				   statement is reversed from what it would
				   be if the actual angles were compared. */
                    if (cos_xmtr_angle >= cos_test_angle) {
                        block = 1;
                    }
                }

                if (block == 0) {
                    OrMask(path.getLat(y), path.getLon(y), mask_value);
                }
            }
        }
    }

    void PlotLRPath(Site source, Site destination, int mask_value, FileWriter wri) throws IOException {
       


        /* This function plots the RF path loss between source and
	   destination points based on the ITWOM propagation model,
	   taking into account antenna pattern data, if available. */
        int x, y, ifs, ofs, errnum;
        boolean block = false;
        String strmode;
        double loss, azimuth, pattern = 0.0, xmtr_alt,
                dest_alt, xmtr_alt2, dest_alt2, cos_rcvr_angle,
                cos_test_angle = 0.0, test_alt, elevation = 0.0,
                distance = 0.0, four_thirds_earth, rxp, dBm,
                field_strength = 0.0;
        Site temp;

        path = Utils.readPath(source, destination, this, config);

        four_thirds_earth = getConfig().FOUR_THIRDS * getConfig().EARTHRADIUS;

        /* Copy elevations plus clutter along path into the elev[] array. */
        for (x = 1; x < path.getLength() - 1; x++) {
            elev[x + 2] = (path.getElevation()[x] == 0.0 ? path.getElevation()[x] * getConfig().METERS_PER_FOOT : (getClutter() + path.getElevation()[x]) * getConfig().METERS_PER_FOOT);
        }

        /* Copy ending points without clutter */
        elev[2] = path.getElevation()[0] * config.METERS_PER_FOOT;
        elev[path.getLength() + 1] = path.getElevation()[path.getLength() - 1] * getConfig().METERS_PER_FOOT;

        /* Since the only energy the propagation model considers
	   reaching the destination is based on what is scattered
	   or deflected from the first obstruction along the path,
	   we first need to find the location and elevation angle
	   of that first obstruction (if it exists).  This is done
	   using a 4/3rds Earth radius to match the radius used by
	   the irregular terrain propagation model.  This information
	   is required for properly integrating the antenna's elevation
	   pattern into the calculation for overall path loss. */
        for (y = 2; (y < (path.getLength() - 1) && path.getDistance()[y] <= maxRange); y++) {
            /* Process this point only if it
		   has not already been processed. */

            if ((GetMask(path.getLat(y), path.getLon(y)) & 248) != (mask_value << 3)) {
                distance = 5280.0 * path.getDistance()[y];
                xmtr_alt = four_thirds_earth + source.getAlt() + path.getElevation()[0];
                dest_alt = four_thirds_earth + destination.getAlt() + path.getElevation()[y];
                dest_alt2 = dest_alt * dest_alt;
                xmtr_alt2 = xmtr_alt * xmtr_alt;

                /* Calculate the cosine of the elevation of
			   the receiver as seen by the transmitter. */
                cos_rcvr_angle = ((xmtr_alt2) + (distance * distance) - (dest_alt2)) / (2.0 * xmtr_alt * distance);

                if (cos_rcvr_angle > 1.0) {
                    cos_rcvr_angle = 1.0;
                }

                if (cos_rcvr_angle < -1.0) {
                    cos_rcvr_angle = -1.0;
                }

                if ( wri != null || lr.isGot_elevation_pattern()) // (got_elevation_pattern || fd!=null)
                {
                    /* Determine the elevation angle to the first obstruction
				   along the path IF elevation pattern data is available
				   or an output (.ano) file has been designated. */

                    for (x = 2, block = false; (x < y && !block); x++) {
                        distance = 5280.0 * path.getDistance()[x];

                        test_alt = four_thirds_earth + (path.getElevation()[x] == 0.0 ? path.getElevation()[x] : path.getElevation()[x] + getClutter());

                        /* Calculate the cosine of the elevation
					   angle of the terrain (test point)
					   as seen by the transmitter. */
                        cos_test_angle = ((xmtr_alt2) + (distance * distance) - (test_alt * test_alt)) / (2.0 * xmtr_alt * distance);

                        if (cos_test_angle > 1.0) {
                            cos_test_angle = 1.0;
                        }

                        if (cos_test_angle < -1.0) {
                            cos_test_angle = -1.0;
                        }

                        /* Compare these two angles to determine if
					   an obstruction exists.  Since we're comparing
					   the cosines of these angles rather than
					   the angles themselves, the sense of the
					   following "if" statement is reversed from
				  	   what it would be if the angles themselves
					   were compared. */
                        if (cos_rcvr_angle >= cos_test_angle) {
                            block = true;
                        }
                    }

                    if (block) {
                        elevation = ((Math.acos(cos_test_angle)) / config.DEG2RAD) - 90.0;
                    } else {
                        double k = (Math.acos(cos_rcvr_angle));
                        double j = (Math.acos(cos_rcvr_angle)) / config.DEG2RAD;
                        elevation = ((Math.acos(cos_rcvr_angle)) / config.DEG2RAD) - 90.0;
                    }
                }

                /* Determine attenuation for each point along
			   the path using ITWOM's point_to_point mode
			   starting at y=2 (number_of_points = 1), the
			   shortest distance terrain can play a role in
			   path loss. */
                elev[0] = y - 1;
                /* (number of points - 1) */

 /* Distance between elevation samples */
                elev[1] = config.METERS_PER_MILE * (path.getDistance()[y] - path.getDistance()[y - 1]);

                ITWOMResult result = null;
                if (olditm) {
                  result =  new ITWOM3().point_to_point_ITM(elev, source.getAlt() * getConfig().METERS_PER_FOOT,
                            destination.getAlt() * config.METERS_PER_FOOT, lr.getEps_dielect(), lr.getSgm_conductivity(), lr.getEno_ns_surfref(), lr.getFrq_mhz(), lr.getRadio_climate(), lr.getPol(), lr.getConf(), lr.getRel());
                } else {
                 result =   new ITWOM3().point_to_point(elev, source.getAlt() * getConfig().METERS_PER_FOOT,
                            destination.getAlt() * config.METERS_PER_FOOT, lr.getEps_dielect(), lr.getSgm_conductivity(), lr.getEno_ns_surfref(), lr.getFrq_mhz(), lr.getRadio_climate(), lr.getPol(), lr.getConf(), lr.getRel());
                }
                
                loss = result.getLoss();
                errnum = result.getErrnum();
                strmode = result.getStrmode();

                temp = new Site("", "", path.getLat(y), path.getLon(y), 0);

                azimuth = (Utils.azimuth(source, temp, config));

                if (wri != null) {
                    wri.write(String.format("%.7f, %.7f, %.3f, %.3f, ", path.getLat(y), path.getLon(y), azimuth, elevation));
                }

                /* If ERP==0, write path loss to alphanumeric
			   output file.  Otherwise, write field strength
			   or received power level (below), as appropriate. */
                if (wri != null && lr.getErp() == 0.0) {
                    wri.write(String.format("%.2f", loss));
                }

                /* Integrate the antenna's radiation
			   pattern into the overall path loss. */
                x = (int) Math.rint(10.0 * (10.0 - elevation));

                if (x >= 0 && x <= 1000) {
                    azimuth = Math.rint(azimuth);

                    pattern = (double) lr.getAntenna_pattern()[(int) azimuth][x];

                    if (pattern != 0.0) {
                        pattern = 20.0 * Math.log10(pattern);
                        loss -= pattern;
                    }
                }

                if (lr.getErp() != 0.0) {
                    if (isDbm()) {
                        /* dBm is based on EIRP (ERP + 2.14) */

                        rxp = lr.getErp() / (Math.pow(10.0, (loss - 2.14) / 10.0));

                        dBm = 10.0 * (Math.log10(rxp * 1000.0));

                        if (wri != null) {
                            wri.write(String.format("%.3f", dBm));
                        }

                        /* Scale roughly between 0 and 255 */
                        ifs = 200 + (int) Math.rint(dBm);

                        if (ifs < 0) {
                            ifs = 0;
                        }

                        if (ifs > 255) {
                            ifs = 255;
                        }

                        ofs = GetSignal(path.getLat(y), path.getLon(y)); //.getLat(y),path.getLon(y));

                        if (ofs > ifs) {
                            ifs = ofs;
                        }

                        PutSignal(path.getLat(y), path.getLon(y), ifs);
                    } else {
                        field_strength = (139.4 + (20.0 * Math.log10(lr.getFrq_mhz())) - loss) + (10.0 * Math.log10(lr.getErp() / 1000.0));

                        ifs = 100 + (int) Math.rint(field_strength);

                        if (ifs < 0) {
                            ifs = 0;
                        }

                        if (ifs > 255) {
                            ifs = 255;
                        }

                        ofs = GetSignal(path.getLat(y), path.getLon(y));

                        if (ofs > ifs) {
                            ifs = ofs;
                        }

                        PutSignal(path.getLat(y), path.getLon(y), ifs);

                        if (wri != null) {
                            wri.write(String.format("%.3f", field_strength));
                        }
                    }
                } else {
                    if (loss > 255) {
                        ifs = 255;
                    } else {
                        ifs = (int) Math.rint(loss);
                    }

                    ofs = GetSignal(path.getLat(y), path.getLon(y));

                    if (ofs < ifs && ofs != 0) {
                        ifs = ofs;
                    }

                    PutSignal(path.getLat(y), path.getLon(y), ifs);
                }

                if (wri != null) {
                    if (block) {
                        wri.write(" *");
                    }

                    wri.write("\n");
                }

                /* Mark this point as having been analyzed */
                PutMask(path.getLat(y), path.getLon(y), (GetMask(path.getLat(y), path.getLon(y)) & 7) + (mask_value << 3));
            }
        }
    }

    void PlotLOSMap(Site source, double altitude) {
        /* This function performs a 360 degree sweep around the
	   transmitter site (source location), and plots the
	   line-of-sight coverage of the transmitter on the SPLAT!
	   generated topographic map based on a receiver located
	   at the specified altitude (in feet AGL).  Results
	   are stored in memory, and written out in the form
	   of a topographic map when the WritePPM() function
	   is later invoked. */

        int y, z, count;
        Site edge;
        char[] symbol = new char[4];
        char x;
        double lat, lon, minwest, maxnorth, th;
        //char mask_value = 1;

        symbol[0] = '.';
        symbol[1] = 'o';
        symbol[2] = 'O';
        symbol[3] = 'o';

        count = 0;

        System.out.printf("\nComputing line-of-sight coverage of \"%s\" with an RX antenna\nat %.2f %s AGL", source.getName(), metric ? altitude * getConfig().METERS_PER_FOOT : altitude, metric ? "meters" : "feet");

        if (getClutter() > 0.0) {
            System.out.printf(" and %.2f %s of ground clutter", metric ? clutter * config.METERS_PER_FOOT : clutter, metric ? "meters" : "feet");
        }

        System.out.print("...\n\n 0% to  25% ");

        /* th=pixels/degree divided by 64 loops per
	   progress indicator symbol (.oOo) printed. */
        th = ppd / 64.0;

        z = (int) (th * Utils.reduceAngle(maxWest - minWest, config));

        minwest = dpp + (double) minWest;
        maxnorth = (double) maxNorth - dpp;

        double lg = Utils.lonDiff(minwest, (double) maxWest);
        for (lon = minwest, x = 0, y = 0; (Utils.lonDiff(lon, (double) maxWest) <= 0.0); y++, lon = minwest + (dpp * (double) y)) {
            if (lon >= 360.0) {
                lon -= 360.0;
            }

            edge = new Site("", "", maxNorth, lon, (float)altitude);
       
            PlotPath(source, edge, mask_value);
            count++;

            if (count == z) {
                System.out.printf("%c", symbol[x]);
                count = 0;

                if (x == 3) {
                    x = 0;
                } else {
                    x++;
                }
            }
        }

        count = 0;
        System.out.print("\n25% to  50%");

        z = (int) (th * (double) (maxNorth - minNorth));

        for (lat = maxnorth, x = 0, y = 0; lat >= (double) minNorth; y++, lat = maxnorth - (dpp * (double) y)) {

            edge = new Site("", "", lat, minWest, (float)altitude);

            PlotPath(source, edge, mask_value);
            count++;

            if (count == z) {
                System.out.printf("%c", symbol[x]);
                count = 0;

                if (x == 3) {
                    x = 0;
                } else {
                    x++;
                }
            }
        }

        count = 0;
        System.out.print("\n50% to  75%");

        z = (int) (th * Utils.reduceAngle(maxWest - minWest, config));

        for (lon = minwest, x = 0, y = 0; (Utils.lonDiff(lon, (double) maxWest) <= 0.0); y++, lon = minwest + (dpp * (double) y)) {
            if (lon >= 360.0) {
                lon -= 360.0;
            }
            edge = new Site("", "", minNorth, lon, (float)altitude);

            PlotPath(source, edge, mask_value);
            count++;

            if (count == z) {
                System.out.printf("%c", symbol[x]);
                count = 0;

                if (x == 3) {
                    x = 0;
                } else {
                    x++;
                }
            }
        }

        count = 0;
        System.out.print("\n75% to 100%");

        z = (int) (th * (double) (maxNorth - minNorth));

        for (lat = (double) minNorth, x = 0, y = 0; lat < (double) maxNorth; y++, lat = (double) minNorth + (getDpp() * (double) y)) {
            edge = new Site("", "", lat, maxWest, (float)altitude);

            PlotPath(source, edge, mask_value);
            count++;

            if (count == z) {
                System.out.printf("%c", symbol[x]);
                count = 0;

                if (x == 3) {
                    x = 0;
                } else {
                    x++;
                }
            }
        }

        System.out.print("\nDone!\n");

        /* Assign next mask value */
        switch (mask_value) {
            case 1:
                mask_value = 8;
                break;

            case 8:
                mask_value = 16;
                break;

            case 16:
                mask_value = 32;
        }
    }

    void PlotLRMap(Site source, double altitude, String plo_filename) {
        /* This function performs a 360 degree sweep around the
	   transmitter site (source location), and plots the
	   Irregular Terrain Model attenuation on the SPLAT!
	   generated topographic map based on a receiver located
	   at the specified altitude (in feet AGL).  Results
	   are stored in memory, and written out in the form
	   of a topographic map when the WriteLRImage() or
	   WriteSSImage() functions are later invoked. */

        int y, z, count;
        Site edge;
        double lat, lon, minwest, maxnorth, th;
        char x;
        char[] symbol = new char[4];
        int mask_value = 1;
        File fd = null;

        minwest = getDpp() + (double) minWest;
        maxnorth = (double) maxNorth - dpp;

        symbol[0] = '.';
        symbol[1] = 'o';
        symbol[2] = 'O';
        symbol[3] = 'o';

        count = 0;

        if (olditm) {
            System.out.print("\nComputing ITM ");
        } else {
            System.out.print("\nComputing ITWOM ");
        }

        if ((this.lr == null? this.forcedErp : this.lr.getErp()) == 0.0) {
            System.out.print("path loss");
        } else {
            if (isDbm()) {
                System.out.print("signal power level");
            } else {
                System.out.print("field strength");
            }
        }

        System.out.printf(" contours of \"%s\"\nout to a radius of %.2f %s with an RX antenna at %.2f %s AGL", source.getName(), metric ? maxRange * config.KM_PER_MILE : maxRange, metric ? "kilometers" : "miles", metric ? altitude * config.METERS_PER_FOOT : altitude, metric ? "meters" : "feet");

        if (getClutter() > 0.0) {
            System.out.printf("\nand %.2f %s of ground clutter", metric ? clutter * config.METERS_PER_FOOT : clutter, metric ? "meters" : "feet");
        }

        

        if (plo_filename != null) {
            FileWriter wri = null;
            try {
                File ploFile = new File(plo_filename);
                wri = new FileWriter(ploFile);
                /* Write header information to output file */
                wri.write(String.format("%d, %d\t; max_west, min_west\n%d, %d\t; max_north, min_north\n", maxWest, minWest, maxNorth, minNorth));
                /* th=pixels/degree divided by 64 loops per
                progress indicator symbol (.oOo) printed. */
                th = getPpd() / 64.0;
                System.out.print("...\n\n 0% to  25% ");
                z = (int) (th * Utils.reduceAngle(maxWest - minWest, config));
                for (lon = minwest, x = 0, y = 0; (Utils.lonDiff(lon, (double) maxWest) <= 0.0); y++, lon = minwest + (dpp * (double) y)) {
                    if (lon >= 360.0) {
                        lon -= 360.0;
                    }

                    edge = new Site("", "", maxNorth, lon, (float)altitude);

                    PlotLRPath(source, edge, mask_value, wri);
                    count++;

                    if (count == z) {
                        System.out.printf("%c", symbol[x]);
                        count = 0;

                        if (x == 3) {
                            x = 0;
                        } else {
                            x++;
                        }
                    }
                }
                count = 0;
                System.out.print("\n25% to  50% ");
                z = (int) (th * (double) (maxNorth - minNorth));
                for (lat = maxnorth, x = 0, y = 0; lat >= (double) minNorth; y++, lat = maxnorth - (dpp * (double) y)) {

                    edge = new Site("", "", lat, minWest, (float)altitude);

                    PlotLRPath(source, edge, mask_value, wri);
                    count++;

                    if (count == z) {
                        System.out.printf("%c", symbol[x]);
                        count = 0;

                        if (x == 3) {
                            x = 0;
                        } else {
                            x++;
                        }
                    }
                }
                count = 0;
                System.out.print("\n50% to  75% ");
                z = (int) (th * Utils.reduceAngle(maxWest - minWest, config));
                for (lon = minwest, x = 0, y = 0; (Utils.lonDiff(lon, (double) maxWest) <= 0.0); y++, lon = minwest + (dpp * (double) y)) {
                    if (lon >= 360.0) {
                        lon -= 360.0;
                    }
                    edge = new Site("", "", minNorth, lon, (float)altitude);

                    PlotLRPath(source, edge, mask_value, wri);
                    count++;

                    if (count == z) {
                        System.out.print(symbol[x]);
                        count = 0;

                        if (x == 3) {
                            x = 0;
                        } else {
                            x++;
                        }
                    }
                }
                count = 0;
                System.out.print("\n75% to 100% ");
                z = (int) (th * (double) (maxNorth - minNorth));
                for (lat = (double) minNorth, x = 0, y = 0; lat < (double) maxNorth; y++, lat = (double) minNorth + (dpp * (double) y)) {

                    edge = new Site("", "", lat, maxWest, (float)altitude);

                    PlotLRPath(source, edge, mask_value, wri);
                    count++;

                    if (count == z) {
                        System.out.print(symbol[x]);
                        count = 0;

                        if (x == 3) {
                            x = 0;
                        } else {
                            x++;
                        }
                    }
                }
                System.out.print("\nDone!\n");
                if (mask_value < 30) {
                    mask_value++;
                }
            } catch (IOException ex) {
                Logger.getLogger(SplatEngine.class.getName()).log(Level.SEVERE, null, ex);
            } finally {
                try {
                    wri.close();
                } catch (IOException ex) {
                    Logger.getLogger(SplatEngine.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
        }
    }
        /**
         * @return the config
         */
    public Configuration getConfig() {
        return config;
    }

    /**
     * @param config the config to set
     */
    public void setConfig(Configuration config) {
        this.config = config;
    }

    /**
     * @return the string
     */
    public String getString() {
        return string;
    }

    /**
     * @param string the string to set
     */
    public void setString(String string) {
        this.string = string;
    }

    /**
     * @return the sdfPath
     */
    public String getSdfPath() {
        return sdfPath;
    }

    /**
     * @param sdfPath the sdfPath to set
     */
    public void setSdfPath(String sdfPath) {
        this.sdfPath = sdfPath;
    }

    /**
     * @return the opened
     */
    public String getOpened() {
        return opened;
    }

    /**
     * @param opened the opened to set
     */
    public void setOpened(String opened) {
        this.opened = opened;
    }

    
    /**
     * @return the dashes
     */
    public String getDashes() {
        return dashes;
    }

    /**
     * @param dashes the dashes to set
     */
    public void setDashes(String dashes) {
        this.dashes = dashes;
    }

    /**
     * @return the earthradius
     */
    public double getEarthradius() {
        return earthradius;
    }

    /**
     * @param earthradius the earthradius to set
     */
    public void setEarthradius(double earthradius) {
        this.earthradius = earthradius;
    }

    /**
     * @return the forcedErp
     */
    public double getForcedErp() {
        return forcedErp;
    }

    /**
     * @param forcedErp the forcedErp to set
     */
    public void setForcedErp(double forcedErp) {
        this.forcedErp = forcedErp;
    }

    /**
     * @return the dpp
     */
    public double getDpp() {
        return dpp;
    }

    /**
     * @param dpp the dpp to set
     */
    public void setDpp(double dpp) {
        this.dpp = dpp;
    }

    /**
     * @return the ppd
     */
    public double getPpd() {
        return ppd;
    }

    /**
     * @param ppd the ppd to set
     */
    public void setPpd(double ppd) {
        this.ppd = ppd;
    }

    /**
     * @return the fzoneClearance
     */
    public double getFzoneClearance() {
        return fzoneClearance;
    }

    /**
     * @param fzoneClearance the fzoneClearance to set
     */
    public void setFzoneClearance(double fzoneClearance) {
        this.fzoneClearance = fzoneClearance;
    }

    /**
     * @return the forcedFreq
     */
    public double getForcedFreq() {
        return forcedFreq;
    }

    /**
     * @param forcedFreq the forcedFreq to set
     */
    public void setForcedFreq(double forcedFreq) {
        this.forcedFreq = forcedFreq;
    }

    /**
     * @return the clutter
     */
    public double getClutter() {
        return clutter;
    }

    /**
     * @param clutter the clutter to set
     */
    public void setClutter(double clutter) {
        this.clutter = clutter;
    }

    /**
     * @return the minNorth
     */
    public int getMinNorth() {
        return minNorth;
    }

    /**
     * @param minNorth the minNorth to set
     */
    public void setMinNorth(int minNorth) {
        this.minNorth = minNorth;
    }

    /**
     * @return the maxNorth
     */
    public int getMaxNorth() {
        return maxNorth;
    }

    /**
     * @param maxNorth the maxNorth to set
     */
    public void setMaxNorth(int maxNorth) {
        this.maxNorth = maxNorth;
    }

    /**
     * @return the minWest
     */
    public int getMinWest() {
        return minWest;
    }

    /**
     * @param minWest the minWest to set
     */
    public void setMinWest(int minWest) {
        this.minWest = minWest;
    }

    /**
     * @return the maxWest
     */
    public int getMaxWest() {
        return maxWest;
    }

    /**
     * @param maxWest the maxWest to set
     */
    public void setMaxWest(int maxWest) {
        this.maxWest = maxWest;
    }

    /**
     * @return the ippd
     */
    public int getIppd() {
        return ippd;
    }

    /**
     * @param ippd the ippd to set
     */
    public void setIppd(int ippd) {
        this.ippd = ippd;
    }

    /**
     * @return the mpi
     */
    public int getMpi() {
        return mpi;
    }

    /**
     * @param mpi the mpi to set
     */
    public void setMpi(int mpi) {
        this.mpi = mpi;
    }

    /**
     * @return the maxElevation
     */
    public int getMaxElevation() {
        return maxElevation;
    }

    /**
     * @param maxElevation the maxElevation to set
     */
    public void setMaxElevation(int maxElevation) {
        this.maxElevation = maxElevation;
    }

    /**
     * @return the minElevation
     */
    public int getMinElevation() {
        return minElevation;
    }

    /**
     * @param minElevation the minElevation to set
     */
    public void setMinElevation(int minElevation) {
        this.minElevation = minElevation;
    }

    /**
     * @return the bzerror
     */
    public int getBzerror() {
        return bzerror;
    }

    /**
     * @param bzerror the bzerror to set
     */
    public void setBzerror(int bzerror) {
        this.bzerror = bzerror;
    }

    /**
     * @return the contourThreshold
     */
    public int getContourThreshold() {
        return contourThreshold;
    }

    /**
     * @param contourThreshold the contourThreshold to set
     */
    public void setContourThreshold(int contourThreshold) {
        this.contourThreshold = contourThreshold;
    }

   
    /**
     * @return the metric
     */
    public boolean isMetric() {
        return metric;
    }

    /**
     * @param metric the metric to set
     */
    public void setMetric(boolean metric) {
        this.metric = metric;
    }

    /**
     * @return the dbm
     */
    public boolean isDbm() {
        return dbm;
    }

    /**
     * @param dbm the dbm to set
     */
    public void setDbm(boolean dbm) {
        this.dbm = dbm;
    }

    /**
     * @return the smoothContours
     */
    public boolean isSmoothContours() {
        return smoothContours;
    }

    /**
     * @param smoothContours the smoothContours to set
     */
    public void setSmoothContours(boolean smoothContours) {
        this.smoothContours = smoothContours;
    }

    /**
     * @return the elev
     */
    public double[] getElev() {
        return elev;
    }

    /**
     * @return the kml
     */
    public boolean isKml() {
        return kml;
    }

    /**
     * @param kml the kml to set
     */
    public void setKml(boolean kml) {
        this.kml = kml;
    }

    /**
     * @return the geo
     */
    public boolean isGeo() {
        return geo;
    }

    /**
     * @param geo the geo to set
     */
    public void setGeo(boolean geo) {
        this.geo = geo;
    }

    /**
     * @return the maxRange
     */
    public double getMaxRange() {
        return maxRange;
    }

    /**
     * @param maxRange the maxRange to set
     */
    public void setMaxRange(double maxRange) {
        this.maxRange = maxRange;
    }

    /**
     * @return the coverage
     */
    public boolean isCoverage() {
        return coverage;
    }

    /**
     * @param coverage the coverage to set
     */
    public void setCoverage(boolean coverage) {
        this.coverage = coverage;
    }

    /**
     * @return the LRmap
     */
    public boolean isLRmap() {
        return LRmap;
    }

    /**
     * @param LRmap the LRmap to set
     */
    public void setLRmap(boolean LRmap) {
        this.LRmap = LRmap;
    }

    /**
     * @return the terrain_plot
     */
    public boolean isTerrain_plot() {
        return terrain_plot;
    }

    /**
     * @param terrain_plot the terrain_plot to set
     */
    public void setTerrain_plot(boolean terrain_plot) {
        this.terrain_plot = terrain_plot;
    }

    /**
     * @return the elevation_plot
     */
    public boolean isElevation_plot() {
        return elevation_plot;
    }

    /**
     * @param elevation_plot the elevation_plot to set
     */
    public void setElevation_plot(boolean elevation_plot) {
        this.elevation_plot = elevation_plot;
    }

    /**
     * @return the height_plot
     */
    public boolean isHeight_plot() {
        return height_plot;
    }

    /**
     * @param height_plot the height_plot to set
     */
    public void setHeight_plot(boolean height_plot) {
        this.height_plot = height_plot;
    }

    /**
     * @return the map
     */
    public boolean isMap() {
        return map;
    }

    /**
     * @param map the map to set
     */
    public void setMap(boolean map) {
        this.map = map;
    }

    /**
     * @return the longley_plot
     */
    public boolean isLongley_plot() {
        return longley_plot;
    }

    /**
     * @param longley_plot the longley_plot to set
     */
    public void setLongley_plot(boolean longley_plot) {
        this.longley_plot = longley_plot;
    }

    /**
     * @return the norm
     */
    public boolean isNorm() {
        return norm;
    }

    /**
     * @param norm the norm to set
     */
    public void setNorm(boolean norm) {
        this.norm = norm;
    }

    /**
     * @return the topomap
     */
    public boolean isTopomap() {
        return topomap;
    }

    /**
     * @param topomap the topomap to set
     */
    public void setTopomap(boolean topomap) {
        this.topomap = topomap;
    }

    /**
     * @return the pt2pt_mode
     */
    public boolean isPt2pt_mode() {
        return pt2pt_mode;
    }

    /**
     * @param pt2pt_mode the pt2pt_mode to set
     */
    public void setPt2pt_mode(boolean pt2pt_mode) {
        this.pt2pt_mode = pt2pt_mode;
    }

    /**
     * @return the area_model
     */
    public boolean isArea_model() {
        return area_model;
    }

    /**
     * @param area_model the area_model to set
     */
    public void setArea_model(boolean area_model) {
        this.area_model = area_model;
    }

    /**
     * @return the ngs
     */
    public boolean isNgs() {
        return ngs;
    }

    /**
     * @param ngs the ngs to set
     */
    public void setNgs(boolean ngs) {
        this.ngs = ngs;
    }

    /**
     * @return the nolospath
     */
    public boolean isNolospath() {
        return nolospath;
    }

    /**
     * @param nolospath the nolospath to set
     */
    public void setNolospath(boolean nolospath) {
        this.nolospath = nolospath;
    }

    /**
     * @return the fresnel_plot
     */
    public boolean isFresnel_plot() {
        return fresnel_plot;
    }

    /**
     * @param fresnel_plot the fresnel_plot to set
     */
    public void setFresnel_plot(boolean fresnel_plot) {
        this.fresnel_plot = fresnel_plot;
    }

    /**
     * @return the command_line_log
     */
    public boolean isCommand_line_log() {
        return command_line_log;
    }

    /**
     * @return the dem
     */
    public Dem[] getDem() {
        return dem;
    }

    /**
     * @param dem the dem to set
     */
    public void setDem(int x, Dem dem) {
        this.dem[x] = dem;
    }

    /**
     * @param command_line_log the command_line_log to set
     */
    public void setCommand_line_log(boolean command_line_log) {
        this.command_line_log = command_line_log;
    }

    /**
     * @return the olditm
     */
    public boolean isOlditm() {
        return olditm;
    }

    /**
     * @param olditm the olditm to set
     */
    public void setOlditm(boolean olditm) {
        this.olditm = olditm;
    }

    /**
     * @return the smooth_contours
     */
    public boolean isSmooth_contours() {
        return smooth_contours;
    }

    /**
     * @param smooth_contours the smooth_contours to set
     */
    public void setSmooth_contours(boolean smooth_contours) {
        this.smooth_contours = smooth_contours;
    }

    /**
     * @return the area_mode
     */
    public boolean isArea_mode() {
        return area_mode;
    }

    /**
     * @param area_mode the area_mode to set
     */
    public void setArea_mode(boolean area_mode) {
        this.area_mode = area_mode;
    }

    /**
     * @return the gpsav
     */
    public boolean isGpsav() {
        return gpsav;
    }

    /**
     * @param gpsav the gpsav to set
     */
    public void setGpsav(boolean gpsav) {
        this.gpsav = gpsav;
    }

    /**
     * @param elev the elev to set
     */
    public void setElev(double[] elev) {
        this.elev = elev;
    }

    /**
     * @return the altitude
     */
    public double getAltitude() {
        return altitude;
    }

    /**
     * @param altitude the altitude to set
     */
    public void setAltitude(double altitude) {
        this.altitude = altitude;
    }

    /**
     * @return the LRaltitude
     */
    public double getLRaltitude() {
        return LRaltitude;
    }

    /**
     * @param LRaltitude the LRaltitude to set
     */
    public void setLRaltitude(double LRaltitude) {
        this.LRaltitude = LRaltitude;
    }

    /**
     * @return the noSitesReport
     */
    public boolean isNoSitesReport() {
        return noSitesReport;
    }

    /**
     * @param noSitesReport the noSitesReport to set
     */
    public void setNoSitesReport(boolean noSitesReport) {
        this.noSitesReport = noSitesReport;
    }

    /**
     * @return the version
     */
    public String getVersion() {
        return version;
    }

    /**
     * @return the name
     */
    public String getName() {
        return name;
    }

    /**
     * @return the lr
     */
    public LR getLr() {
        return lr;
    }

    /**
     * @param lr the lr to set
     */
    public void setLr(LR lr) {
        this.lr = lr;
    }

    /**
     * @return the generatePng
     */
    public boolean isGeneratePpm() {
        return generatePpm;
    }

    /**
     * @param generatePng the generatePng to set
     */
    public void setGeneratePpm(boolean generatePpm) {
        this.generatePpm = generatePpm;
    }

    /**
     * @return the isTransparentPng
     */
    public boolean isTransparentPng() {
        return isTransparentPng;
    }

    /**
     * @param isTransparentPng the isTransparentPng to set
     */
    public void setTransparentPng(boolean isTransparentPng) {
        this.isTransparentPng = isTransparentPng;
    }

}
